<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SyncFromNotion</title>
  <style>
    /* Reset & Base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Inter', sans-serif;
      background-color: #2c2c2c;
      color: #fff;
      font-size: 11px;
      padding: 16px;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* Helper Classes */
    .hidden { display: none !important; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .gap-8 { gap: 8px; }
    .gap-4 { gap: 4px; }
    .items-center { align-items: center; }
    .justify-between { justify-content: space-between; }
    .w-full { width: 100%; }
    .mb-8 { margin-bottom: 8px; }
    .mb-16 { margin-bottom: 16px; }

    /* Component Styles */
    h2 { font-size: 13px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 6px; }
    h2::before { content: 'ğŸ”„'; font-size: 12px; }
    
    label { color: #b3b3b3; margin-bottom: 4px; display: block; }
    
    input, select {
      background: #3c3c3c;
      border: 1px solid #3c3c3c;
      color: #fff;
      padding: 8px;
      border-radius: 4px;
      font-size: 11px;
      width: 100%;
      outline: none;
    }
    input:focus, select:focus { border-color: #18a0fb; }
    input::placeholder { color: #888; }
    
    /* Buttons */
    button {
      background: #18a0fb;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 500;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
    }
    button:hover { background: #0d8ce0; }
    button:disabled { background: #555; cursor: not-allowed; color: #aaa; }
    button.secondary { background: transparent; border: 1px solid #555; color: #ccc; }
    button.secondary:hover { border-color: #888; color: #fff; }

    /* Steps */
    .step-container { flex: 1; overflow-y: auto; padding-right: 2px; }
    .step-header { font-weight: 600; color: #fff; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #444; }
    
    /* Mapping List */
    .mapping-item {
      background: #333;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 6px;
      border: 1px solid #444;
    }
    .layer-info { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .layer-icon { font-size: 10px; color: #888; }
    .layer-name { font-weight: 500; color: #ddd; }
    .layer-type { font-size: 9px; background: #444; padding: 2px 4px; border-radius: 2px; color: #aaa; }

    /* Status Bar */
    .status-bar {
      margin-top: auto;
      padding-top: 12px;
      border-top: 1px solid #444;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 10px;
      color: #999;
    }
    .spinner {
      width: 10px; height: 10px;
      border: 2px solid #555; border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

  </style>
</head>
<body>

  <h2>SyncFromNotion v2</h2>

  <div id="step-1" class="step-container">
    <div class="step-header">Step 1: ç²å–æ•¸æ“š</div>
    <div class="mb-16">
      <label>Webhook URL</label>
      <input type="text" id="webhook-url" placeholder="https://hook.us2.make.com/..." />
    </div>
    <button id="btn-fetch" class="w-full">ğŸ“¥ æ‹‰å–æ•¸æ“š</button>
  </div>

  <div id="step-preview" class="step-container hidden">
    <div class="step-header">Step 1.5: æ•¸æ“šé è¦½</div>
    <p class="mb-8" style="color:#aaa">ç¢ºèªæ¬„ä½èˆ‡å…§å®¹æ˜¯å¦æ­£ç¢º (é¡¯ç¤ºç¬¬1ç­†)</p>
    <div id="preview-list" class="mb-16" style="max-height: 250px; overflow-y: auto; background: #222; padding: 8px; border: 1px solid #444; border-radius: 4px;">
      <!-- Preview items -->
    </div>
    <div class="flex gap-8">
      <button id="btn-preview-back" class="secondary">é‡æ–°è¼¸å…¥ URL</button>
      <button id="btn-preview-refresh" class="secondary">ğŸ”„ åˆ·æ–°</button>
      <button id="btn-preview-next" class="w-full">ä¸‹ä¸€æ­¥ï¼šé¸æ“‡çµ„ä»¶</button>
    </div>
  </div>

  <div id="step-2" class="step-container hidden">
    <div class="step-header">Step 2: é¸æ“‡çµ„ä»¶</div>
    <p class="mb-8" style="color:#aaa">è«‹åœ¨ Figma ç•«å¸ƒä¸Šé¸ä¸­ä¸€å€‹ Componentï¼Œç„¶å¾Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•ã€‚</p>
    <div class="mb-16 p-2 bg-gray-800 rounded border border-gray-700 hidden" id="selected-comp-info" style="background:#222; padding:8px; border:1px solid #444;">
      <div style="font-weight:bold" id="comp-name">--</div>
    </div>
    <button id="btn-read-selection" class="w-full secondary">ğŸ” è®€å–é¸ä¸­çš„ Component</button>
  </div>

  <div id="step-3" class="step-container hidden">
    <div class="step-header">Step 3: æ˜ å°„æ¬„ä½</div>
    
    <div class="mb-16">
      <label>å”¯ä¸€ ID æ¬„ä½ (è­˜åˆ¥ç”¨)</label>
      <select id="id-field-select"></select>
    </div>

    <label class="mb-8">åœ–å±¤å°æ‡‰é—œä¿‚</label>
    <div id="mapping-list">
      <!-- Mappings will be injected here -->
    </div>
    
    <div class="flex gap-8 mt-4">
      <button id="btn-back-2" class="secondary">ä¸Šä¸€æ­¥</button>
      <button id="btn-sync" class="w-full">ğŸš€ é–‹å§‹åŒæ­¥</button>
    </div>
  </div>

  <div class="status-bar">
    <div id="spinner" class="spinner hidden"></div>
    <span id="status-text">å°±ç·’</span>
  </div>

  <script>
    // --- State ---
    let notionData = [];
    let schemaKeys = [];
    let componentLayers = [];
    let currentComponentId = null;
    let currentMappings = []; // [New] Store mappings for image sync phase

    // --- Elements ---
    const steps = {
      1: document.getElementById('step-1'),
      'preview': document.getElementById('step-preview'),
      2: document.getElementById('step-2'),
      3: document.getElementById('step-3')
    };
    const webhookInput = document.getElementById('webhook-url');
    const btnFetch = document.getElementById('btn-fetch');
    const btnPreviewNext = document.getElementById('btn-preview-next');
    const btnPreviewBack = document.getElementById('btn-preview-back');
    const previewList = document.getElementById('preview-list');
    const btnReadSelection = document.getElementById('btn-read-selection');
    const btnSync = document.getElementById('btn-sync');
    const btnBack2 = document.getElementById('btn-back-2');
    const mappingList = document.getElementById('mapping-list');
    const idFieldSelect = document.getElementById('id-field-select');
    const statusText = document.getElementById('status-text');
    const spinner = document.getElementById('spinner');

    // --- Helpers (Defined early) ---
    function setStatus(type, msg) {
      statusText.textContent = msg;
      statusText.className = type;
      spinner.classList.toggle('hidden', type !== 'loading');
      if (type === 'error') statusText.style.color = '#ff4d4d';
      else if (type === 'success') statusText.style.color = '#4dff88';
      else statusText.style.color = '#999';
    }

    function showStep(n) {
      Object.values(steps).forEach(el => el.classList.add('hidden'));
      steps[n].classList.remove('hidden');
    }

    // --- Actions ---

    // Step 1: Fetch Data
    btnFetch.onclick = async () => {
      const url = webhookInput.value.trim();
      if (!url) return setStatus('error', 'è«‹è¼¸å…¥ URL');
      
      setStatus('loading', 'æ­£åœ¨æ‹‰å–æ•¸æ“š...');
      btnFetch.disabled = true;

      try {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        let data = await resp.json();
        
        // Smart extract array
        if (!Array.isArray(data)) {
          const extracted = extractArray(data);
          if (extracted) {
            data = extracted;
          } else {
            // Show preview of data to help debugging
            const preview = JSON.stringify(data).substring(0, 100);
            throw new Error(`æœªæ‰¾åˆ°æ•¸æ“šé™£åˆ—ã€‚æ”¶åˆ°: ${preview}...`);
          }
        }

        if (data.length === 0) throw new Error('é™£åˆ—ç‚ºç©º (0 items)');

        notionData = data;
        // Extract all unique keys from first few records
        const allKeys = new Set();
        data.slice(0, 5).forEach(item => Object.keys(item).forEach(k => allKeys.add(k)));
        schemaKeys = Array.from(allKeys);

        setStatus('success', `æˆåŠŸç²å– ${data.length} ç­†æ•¸æ“š`);
        
        // Save to cache
        try {
          localStorage.setItem('cached_data', JSON.stringify(data));
        } catch (e) {
          console.warn('Failed to save to cache', e);
        }

        // Render Preview
        renderPreview(data[0]);
        showStep('preview');

      } catch (e) {
        setStatus('error', 'å¤±æ•—: ' + e.message);
      } finally {
        btnFetch.disabled = false;
      }
    };

    // Step 1.5 Preview Actions
    const btnPreviewRefresh = document.getElementById('btn-preview-refresh');
    
    btnPreviewNext.onclick = () => showStep(2);
    btnPreviewBack.onclick = () => showStep(1);
    btnPreviewRefresh.onclick = () => btnFetch.click();

    // Step 2: Read Component
    btnReadSelection.onclick = () => {
      console.log('Sending get-component-layers message...');
      parent.postMessage({ pluginMessage: { type: 'get-component-layers' } }, '*');
      setStatus('loading', 'æ­£åœ¨è®€å– Component...');
    };

    // Step 3 Back
    btnBack2.onclick = () => showStep(2);

    // ... existing code ...

    function extractArray(obj) {
      if (typeof obj !== 'object' || obj === null) return null;
      
      // 1. Try common keys
      const keys = ['data', 'results', 'items', 'records', 'rows', 'list', 'entries', 'json', 'body'];
      for (const k of keys) {
        const val = obj[k];
        if (Array.isArray(val)) return val;
        // Handle stringified JSON (common in some webhooks)
        if (typeof val === 'string') {
          try {
            const parsed = JSON.parse(val);
            if (Array.isArray(parsed)) return parsed;
          } catch {}
        }
      }
      
      // 2. Iterate all keys if strict common keys didn't work
      for (const k of Object.keys(obj)) {
        const val = obj[k];
        if (Array.isArray(val)) return val;
        if (typeof val === 'string') {
          try {
            const parsed = JSON.parse(val);
            if (Array.isArray(parsed)) return parsed;
          } catch {}
        }
      }
      
      return null;
    }

    function renderMappingUI(layers) {
      mappingList.innerHTML = '';
      
      // Populate ID Select
      idFieldSelect.innerHTML = '';
      schemaKeys.forEach(key => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key;
        if (key.toLowerCase() === 'id') opt.selected = true;
        idFieldSelect.appendChild(opt);
      });

      // Populate Layer Mappings
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'mapping-item';
        div.dataset.layer = layer.name;
        div.dataset.type = layer.type;

        let icon = layer.type === 'TEXT' ? 'T' : 'ğŸ–¼ï¸';
        
        // Auto-match logic
        let selectedField = '__ignore__'; // Initialize to ignore

        // Try exact match or match without '#' prefix
        const cleanName = layer.name.replace(/^#/, '');
        if (schemaKeys.includes(layer.name)) {
           selectedField = layer.name;
        } else if (schemaKeys.includes(cleanName)) {
           selectedField = cleanName;
        }

        const optionsHtml = schemaKeys.map(k => 
          `<option value="${k}" ${k === selectedField ? 'selected' : ''}>${k}</option>`
        ).join('');

        div.innerHTML = `
          <div class="layer-info">
            <span class="layer-icon">${icon}</span>
            <span class="layer-name">${layer.name}</span>
            <span class="layer-type">${layer.type}</span>
          </div>
          <select data-dtype="${layer.type === 'TEXT' ? 'text' : 'image'}">
            <option value="__ignore__">-- å¿½ç•¥ --</option>
            ${optionsHtml}
          </select>
        `;
        mappingList.appendChild(div);
      });
    }

    // Step 4: Sync
    btnSync.onclick = () => {
      console.log('é»æ“ŠåŒæ­¥æŒ‰éˆ•');
      setStatus('loading', 'æº–å‚™åŒæ­¥...');
      const mappings = [];
      
      const items = document.querySelectorAll('.mapping-item');
      console.log(`æ‰¾åˆ° ${items.length} å€‹æ˜ å°„é …ç›®`);

      items.forEach(item => {
        const layerName = item.dataset.layer;
        const layerType = item.dataset.type;
        const select = item.querySelector('select');
        const dataField = select.value;
        
        if (dataField && dataField !== '__ignore__') {
          mappings.push({ layerName, dataField, dataType: layerType === 'RECTANGLE' || layerType === 'ELLIPSE' ? 'image' : 'text' });
        }
      });

      console.log('ç”Ÿæˆçš„æ˜ å°„è¦å‰‡:', mappings);

      if (mappings.length === 0) {
        console.warn('æ˜ å°„è¦å‰‡ç‚ºç©º');
        return setStatus('error', 'è«‹è‡³å°‘è¨­å®šä¸€å€‹æ˜ å°„æ¬„ä½');
      }

      const idField = idFieldSelect.value;
      console.log('ID Field:', idField);

      parent.postMessage({ 
        pluginMessage: { 
          type: 'sync-mapped-data',
          componentId: currentComponentId,
          data: notionData,
          mappings,
          idField
        } 
      }, '*');
      
      console.log('å·²ç™¼é€ sync-mapped-data è¨Šæ¯');
      setStatus('loading', 'æ­£åœ¨åŒæ­¥æ•¸æ“š... (è«‹ç¨å€™)');
    };

    async function downloadAndSendImages(mappings) {
      setStatus('loading', 'æ­£åœ¨ä¸‹è¼‰åœ–ç‰‡...');
      let count = 0;
      const total = notionData.length * mappings.length;

      for (let i = 0; i < notionData.length; i++) {
        const item = notionData[i];
        // Must use the same ID logic as code.ts
        const idValue = item[idFieldSelect.value] || `row-${i}`;

        for (const m of mappings) {
          const url = item[m.dataField];
          if (typeof url === 'string' && url.startsWith('http')) {
            try {
              const resp = await fetch(url);
              const buffer = await resp.arrayBuffer();
              parent.postMessage({
                pluginMessage: {
                  type: 'set-image',
                  notionId: String(idValue),
                  layerName: m.layerName,
                  imageBytes: new Uint8Array(buffer)
                }
              }, '*');
            } catch (e) {
              console.warn('Image fail', url);
            }
          }
          count++;
          if (count % 5 === 0) setStatus('loading', `è™•ç†åœ–ç‰‡ ${count}/${total}...`);
        }
      }
      setStatus('success', 'åŒæ­¥å®Œæˆï¼');
      btnSync.disabled = false;
    }

    // --- Helpers ---
    
    function renderPreview(record) {
      previewList.innerHTML = '';
      schemaKeys.forEach(key => {
        const div = document.createElement('div');
        div.className = 'preview-item'; // Changed from mapping-item
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        
        const keySpan = document.createElement('span');
        keySpan.style.fontWeight = 'bold';
        keySpan.style.color = '#ddd';
        keySpan.textContent = key;
        
        const valSpan = document.createElement('span');
        valSpan.style.color = '#aaa';
        valSpan.style.fontSize = '10px';
        valSpan.style.maxWidth = '150px';
        valSpan.style.overflow = 'hidden';
        valSpan.style.textOverflow = 'ellipsis';
        valSpan.style.whiteSpace = 'nowrap';
        let val = record[key];
        if (typeof val === 'object') val = JSON.stringify(val);
        valSpan.textContent = String(val);

        div.appendChild(keySpan);
        div.appendChild(valSpan);
        previewList.appendChild(div);
      });
    }

    // --- Message Handler ---
    window.onmessage = (event) => {
      try {
        const msg = event.data.pluginMessage;
        console.log('Frontend received message:', msg);
        if (!msg) return;

        if (msg.type === 'component-layers') {
          console.log('Processing component-layers...');
          componentLayers = msg.layers;
          currentComponentId = msg.componentId;
          
          try {
            renderMappingUI(componentLayers);
          } catch (e) {
            console.error('Render UI Error:', e);
            setStatus('error', 'æ¸²æŸ“ä»‹é¢å¤±æ•—: ' + e.message);
          }
          
          document.getElementById('comp-name').textContent = msg.componentName;
          document.getElementById('selected-comp-info').classList.remove('hidden');
          
          if (componentLayers.length === 0) {
            setStatus('error', 'æœªæ‰¾åˆ°åç¨±å« # çš„åœ–å±¤ (è«‹æª¢æŸ¥åœ–å±¤åç¨±)');
            btnSync.disabled = true;
          } else {
            setStatus('success', 'å·²è®€å– Componentï¼Œè«‹è¨­å®šæ˜ å°„');
            console.log('Enabling Sync button manually from code');
            btnSync.removeAttribute('disabled'); // Ensure attribute is gone
            btnSync.disabled = false;
          }
          showStep(3);
        }
        else if (msg.type === 'status') {
          setStatus('loading', msg.message);
        }
        else if (msg.type === 'error') {
          setStatus('error', msg.message);
          btnSync.disabled = false;
        }
        if (msg.type === 'done') {
          // Check if we need to sync images
          const imageMappings = currentMappings.filter(m => m.dataType !== 'text');
          
          if (imageMappings.length > 0) {
            setStatus('success', msg.message + ' (é–‹å§‹è™•ç†åœ–ç‰‡...)');
            downloadAndSendImages(imageMappings);
          } else {
            setStatus('success', msg.message);
            btnSync.disabled = false;
          }
        }
      } catch (err) {
        console.error('Window onmessage error:', err);
        setStatus('error', 'Plugin éŒ¯èª¤: ' + err.message);
      }
    };

    // Refactored renderMappingUI for safety
    function renderMappingUI(layers) {
      mappingList.innerHTML = '';
      
      // Populate ID Select
      idFieldSelect.innerHTML = '';
      schemaKeys.forEach(key => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key;
        if (key.toLowerCase() === 'id') opt.selected = true;
        idFieldSelect.appendChild(opt);
      });

      // Populate Layer Mappings
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'mapping-item';
        div.dataset.layer = layer.name;
        div.dataset.type = layer.type;

        let icon = layer.type === 'TEXT' ? 'T' : 'ğŸ–¼ï¸';
        
        const layerInfoComp = document.createElement('div');
        layerInfoComp.className = 'layer-info';
        layerInfoComp.innerHTML = `
            <span class="layer-icon">${icon}</span>
            <span class="layer-name" title="${layer.name}">${layer.name}</span>
            <span class="layer-type">${layer.type}</span>
        `;

        const select = document.createElement('select');
        select.dataset.dtype = layer.type === 'TEXT' ? 'text' : 'image';
        
        // Default Ignore Option
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '__ignore__';
        defaultOpt.textContent = '-- å¿½ç•¥ --';
        select.appendChild(defaultOpt);

        // Auto-match logic
        let selectedField = '__ignore__'; 
        const cleanName = layer.name.replace(/^#/, '');
        if (schemaKeys.includes(layer.name)) {
           selectedField = layer.name;
        } else if (schemaKeys.includes(cleanName)) {
           selectedField = cleanName;
        }

        // Add Schema Options
        schemaKeys.forEach(k => {
          const opt = document.createElement('option');
          opt.value = k;
          opt.textContent = k;
          if (k === selectedField) opt.selected = true;
          select.appendChild(opt);
        });

        div.appendChild(layerInfoComp);
        div.appendChild(select);
        mappingList.appendChild(div);
      });
    }

    // Step 4: Sync
    btnSync.onclick = () => {
      try {
        console.log('é»æ“ŠåŒæ­¥æŒ‰éˆ• (Click triggered)');
        setStatus('loading', 'æ­£åœ¨é–‹å§‹åŒæ­¥...'); // Immediate feedback
        
        const mappings = [];
        // Only select from the mapping list to avoid preview items
        const items = mappingList.querySelectorAll('.mapping-item');
        console.log(`æ‰¾åˆ° ${items.length} å€‹æ˜ å°„é …ç›®`);

        items.forEach(item => {
          const layerName = item.dataset.layer;
          const layerType = item.dataset.type;
          const select = item.querySelector('select');
          
          if (!select) {
            console.warn('Skipping item without select:', item);
            return;
          }
          
          const dataField = select.value;
          
          if (dataField && dataField !== '__ignore__') {
            mappings.push({ layerName, dataField, dataType: layerType !== 'TEXT' ? 'image' : 'text' });
          }
        });

        console.log('ç”Ÿæˆçš„æ˜ å°„è¦å‰‡:', mappings);
        currentMappings = mappings; // Save mappings for image phase

        if (mappings.length === 0) {
          console.warn('æ˜ å°„è¦å‰‡ç‚ºç©º');
          return setStatus('error', 'è«‹è‡³å°‘è¨­å®šä¸€å€‹æ˜ å°„æ¬„ä½');
        }

        const idField = idFieldSelect.value;
        console.log('ID Field:', idField);

        parent.postMessage({ 
          pluginMessage: { 
            type: 'sync-mapped-data',
            componentId: currentComponentId,
            data: notionData,
            mappings,
            idField
          } 
        }, '*');
        
        console.log('å·²ç™¼é€ sync-mapped-data è¨Šæ¯');
        setStatus('loading', 'æ­£åœ¨åŒæ­¥æ•¸æ“š... (è«‹ç¨å€™)');
      } catch (e) {
        console.error('Sync Button Error:', e);
        setStatus('error', 'åŒæ­¥æŒ‰éˆ•éŒ¯èª¤: ' + e.message);
      }
    };

    // --- Init ---
    // --- Init ---
    try {
      const savedUrl = localStorage.getItem('webhook_url');
      if (savedUrl) webhookInput.value = savedUrl;
      
      const savedData = localStorage.getItem('cached_data');
      if (savedData) {
        try {
          const parsed = JSON.parse(savedData);
          if (Array.isArray(parsed) && parsed.length > 0) {
            notionData = parsed;
            const allKeys = new Set();
            parsed.slice(0, 5).forEach(item => Object.keys(item).forEach(k => allKeys.add(k)));
            schemaKeys = Array.from(allKeys);
            renderPreview(parsed[0]);
            showStep('preview');
            setStatus('success', `å·²è¼‰å…¥ç·©å­˜æ•¸æ“š (${parsed.length} ç­†)`);
          }
        } catch (e) {
          console.warn('Failed to parse cached data', e);
        }
      }

      // Auto-fetch if URL exists
      if (savedUrl) {
         // Use a small timeout to allow UI to settle and user to see what's happening
         setTimeout(() => {
           btnFetch.click();
         }, 500);
      }

    } catch (e) {
      console.warn('LocalStorage not available', e);
    }

    webhookInput.onchange = () => {
      try {
        localStorage.setItem('webhook_url', webhookInput.value);
      } catch (e) {}
    };

  </script>
</body>
</html>
